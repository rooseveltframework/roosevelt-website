<include src="layouts/main">
  <arg pageTitle>design philosophy</arg>
  <arg pageId>design-philosophy</arg>
  <arg noVersionPicker>true</arg>
  <arg pageContent>
    <article>
      <blockquote title="President Theodore Roosevelt learns about the merchants of complexity">
        <p class="roosevelt">TAFT HAVE YOU HEARD OF THIS WEB FRAMEWORK BUSINESS</p>
        <p class="taft">yes, sir</p>
        <p class="roosevelt">THEY’RE RIDDLED WITH NEEDLESS COMPLEXITY</p>
        <p class="taft">yes, sir</p>
        <p class="roosevelt">THAT ISN’T SPORTING AT ALL</p>
        <p class="taft">no, sir</p>
        <p class="roosevelt">BRING ME THE WEB FRAMEWORKS</p>
        <p class="roosevelt">I’M GOING TO PUNCH THEM MANFULLY IN THE FACE</p>
        <p class="taft">sir, web frameworks are software, not a person</p>
        <p class="taft">you can’t punch a web framework in the face</p>
        <p class="roosevelt">OH CAN’T I</p>
        <p class="roosevelt">TAFT, WATCH ME BECOME THE FIRST MAN TO PUNCH A WEB FRAMEWORK IN THE FACE</p>
        <p class="roosevelt">THEN WRITE IT DOWN</p>
        <p class="roosevelt">IN YOUR OFFICIAL WHITE HOUSE NOTES</p>
        <p class="roosevelt">“TODAY THE PRESIDENT PUNCHED A WEB FRAMEWORK IN THE FACE”</p>
        <p class="taft">all right</p>
        <p class="roosevelt">“QUITE SOUNDLY TOO”</p>
        <p class="taft">I will</p>
        <p class="roosevelt">“WITH AN EXCELLENT RIGHT UPPER CROSS”</p>
        <p class="taft">yes, sir</p>
        <p class="roosevelt">“CAN’T PUNCH A WEB FRAMEWORK IN THE FACE”</p>
        <p class="roosevelt">FORSOOTH</p>
        <p class="roosevelt">I’M THE PRESIDENT</p>
        <p class="roosevelt">I CAN PUNCH ANYTHING</p>
        <p class="the-toast"><cite>Apologies to <a href="https://the-toast.net/2014/09/16/dirtbag-teddy-roosevelt/">Daniel Mallory Ortberg</a></cite></p>
      </blockquote>

      <p>Roosevelt a web framework based on <a href="https://expressjs.com">Express</a> that aims to be the easiest web framework on the <a href="https://nodejs.org">Node.js</a> stack to learn and use. Suitable for building multi-page apps, static sites, or single page apps, Roosevelt is a batteries-included framework with minimal boilerplate.</p>

      <p>The primary design goal of Roosevelt is to reduce the complexity of your code as much as possible. Teddy Roosevelt — referred to by Cracked magazine as the "<a href="https://www.cracked.com/article_15895_the-5-most-badass-presidents-all-time_p5.html">the most badass President of all-time</a>" — curtailed the abuse of monopolists, so there's no way he would ever put up with all the indecipherable layers of abstractions and other needless complexities common to other web frameworks. If Teddy were around today, he would punch over-engineered frameworks quite soundly in the face, <a href="https://the-toast.net/2014/09/16/dirtbag-teddy-roosevelt/">just as he did with trusts</a>.</p>

      <h2 id="whynotvanilla">So why not just use vanilla Express then?</h2>

      <p>You could! Express is wonderful. But fine-tuning the Express framework for developing serious web apps is a lot of work because it adopts a very minimalist philosophy in its defaults. If you build a vanilla Express web app yourself, you will need to manually include and configure a lot of additional modules to handle very basic things such as handling POST request bodies, file uploads, logging, security hardening, template parsing, CSS/JS preprocessing and bundling, etc. Roosevelt wires up these features for you, sets sane defaults, and more.</p>

      <h2 id="lowjargon">Roosevelt is a low jargon, minimal abstractions framework</h2>

      <p>The best libraries and frameworks exist solely extend and improve existing tools rather than overturn them with complete replacement abstractions. As such, Roosevelt does not replace Express or hide its functionality and features behind an opaque interface like other frameworks that sit in front of Express do. When you use Roosevelt, it simply configures Express for you, adds some features, and then returns an Express app to you to do as you like with. In this way, Roosevelt is merely a <a href="https://en.wikipedia.org/wiki/Progressive_enhancement">progressive enhancement</a> of Express.</p>

      <h2 id="enhancesexpress">Roosevelt enhances Express with</h2>

      <ul>
        <li>A simple, configurable default <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> directory structure.</li>
        <li><a href="/docs/teddy">Teddy</a> HTML templates by default which are much easier to read and maintain than common alternatives. Can be configured to use any templating system that supports Express, or even <a href="/docs/node-php-runner">PHP</a>.</li>
        <li><a href="https://sass-lang.com">Sass</a> CSS preprocessing by default with support for <a href="http://lesscss.org">Less</a> and <a href="https://stylus-lang.com">Stylus</a> too. Minification via <a href="https://www.npmjs.com/package/clean-css">clean-css</a>. Other CSS preprocessors can be used as well with a bit of extra configuration.</li>
        <li><a href="https://webpack.js.org/">Webpack</a> fully integrated providing an easy to use interface for bundling and minifying your frontend JS. Other JS bundlers can be used as well with a bit of extra configuration.</li>
        <li>Automatic <a href="https://en.wikipedia.org/wiki/Progressive_enhancement">progressively enhancement</a> of supported web components in your code with fallback markup that will work if JavaScript is disabled which will then be replaced with the desired web component when the JavaScript loads. Powered by <a href="/docs/progressively-enhance-web-components">progressively-enhance-web-components</a>.</li>
        <li>Automatic code-reloading in development mode via <a href="https://nodemon.io">nodemon</a> for server-side changes and <a href="/docs/express-browser-reload">express-browser-reload</a> for frontend changes.</li>
        <li>Automatic HTML validation in development mode for your post-server-rendered HTML powered by <a href="/docs/express-html-validator">express-html-validator</a>.</li>
      </ul>

      <h2 id="pefirst">Roosevelt is a progressive enhancement-first framework</h2>

      <p>As mentioned briefly above, a core principle behind the design of the Roosevelt framework is promoting <a href="https://en.wikipedia.org/wiki/Progressive_enhancement">progressive enhancement</a> as a best practice in building web applications. We believe progressive enhancement is the best approach not just in regards to how Roosevelt enhances Express, but also with your frontend code as well. This means most web applications should be multi-page apps, not single page apps. It also means with few exceptions you should always focus on writing HTML first, enhance it with CSS as-needed, and enhance your HTML and CSS with JS only as-needed. Avoid JS-first architectures.</p>

      <h3 id="pefrontend">Why progressive enhancement is a best practice on the frontend</h3>

      <p>The web platform was designed with three languages (HTML, CSS, and JS) intentionally: to separate concerns and to allow a subset of functionality to be guaranteed to work even if the user's browser or internet connection can't execute the full intended experience. This is distinct from the all-or-nothing approach that native apps take and is the web's greatest superpower.</p>

      <p>To fully understand this, let's consider a couple of analogies:</p>

      <picture>
        <source srcset="/images/m-m-white.webp" media="(prefers-color-scheme: light)"/>
        <source srcset="/images/m-m-black.webp"  media="(prefers-color-scheme: dark)"/>
        <img src="/images/m-m-light.webp" alt="The Chocolatey Layers of Progressive Enhancement — M&amp;M analogy illustration by Dave Stewart" title="The Chocolatey Layers of Progressive Enhancement — M&amp;M analogy illustration by Dave Stewart" class="float-right rounded-edges">
      </picture>


      <h4 id="peanutmm">HTML, CSS, and JS are kind of <a href="https://alistapart.com/article/understandingprogressiveenhancement/">like a peanut M&amp;M</a></h4>

      <ul>
        <li>HTML is the peanut: Consumable entirely on its own regardless of whether any CSS (chocolate coating) or JS (candy coating) enhancements are added on top of it.</li>
        <li>CSS is the chocolate coating: Chocolate makes the peanut better, but you can eat the peanut without it.</li>
        <li>JS is the candy coating: The candy coating is the best way to experience a peanut M&amp;M, but if the candy coating is missing it's still good without it.</li>
      </ul>

      <h4 id="escalators">Build escalators, not elevators</h4>

      <p>Another analogy that helps us understand progressive enhancement is thinking about the three web languages as helping us <a href="https://christianheilmann.com/2012/02/16/stumbling-on-the-escalator/">build esclators instead of elevators</a>. When you build a JS-first web app that can't function without JS, then you're building an elevator. If the elevator fails, then it's useless. But if you build an escalator instead, then when your escalator fails, it becomes stairs. And handling the non-JS scenario is often <a href="https://www.kryogenix.org/code/browser/everyonehasjs.html">much more important than it may seem</a>.</p>

      <p>Accordingly, Roosevelt's recommended best practice for building single page apps involves using Roosevelt's built-in support for <a href="/docs/single-page-express">Single Page Express</a>, which allows you to build single page apps using the Express API. You can use other SPA frameworks if you like instead, but you should consider Single Page Express because it will allow you to write isomorphic (aka universal, <a href="https://x.com/kethinov/status/566896168324825088">amphibious</a>, etc) controller and view code that can be shared verbatim on the client and the server in your app for maximum code-reuse on the client and server. That means you can server-render every page in your SPA and even support the non-JS scenario with very little extra work, unlike most other SPA architectures.</p>

      <h2 id="goodfastcheap">We prioritize "good" when deciding between "fast, good, and cheap" and so should you</h2>

      <p>It's often said that when presented with the options of "fast, good, or cheap," you need to "<a href="https://fastgood.cheap">pick two</a>" — a demonstration of the classic <a href="https://en.wikipedia.org/wiki/Project_management_triangle">project management triangle</a>. But perhaps somewhat counter-intuitively, it's often best to prioritize "good" over "fast" or "cheap" whenever you can. This is because if you cut corners while developing your product to save time or money, you're often creating a technical debt situation that will cost you as much or more time and money later.</p>

      <p>As such, the only acceptable times to lower the priority of "good" in the pursuit of "fast" or "cheap" is when you're certain the work you're doing is truly a throwaway one-off and won't need to be maintained by anybody, or when the urgency of the situation is so high that you're willing to pay off the technical debt burden later.</p>

      <p>Likewise, just as picking "fast" or "cheap" over "good" can result in you getting none of those things in the long run, prioritizing "good" first can make it possible for you to achieve all three at the same time: "good," "fast," and "cheap" without sacrificing any of them. Achieving that software development nirvana is obviously everyone's dream, and too few ever achieve it. So how can it be done? The answer is by becoming excellent at your craft. The better you are at what you do, the faster you'll work and the less funding you'll need to get things done.</p>

      <img src="/images/padme-reduce-complexity.jpg" alt="Star Wars meme where Anakin says: great devs practice good gitflow, write automated tests, and — then Padme says: reduce needless complexity, right? Then asks again, looking worried." title="Padmé Amidala learns about the merchants of complexity" class="float-right rounded-edges">

      <h3 id="craftsmanship">Reducing complexity as much as possible is a core component of excellent craftsmanship</h3>

      <p>If you want to get to the point in your software development journey where you can check all three boxes in the "good," "fast," or "cheap" project management triangle, you need to use tools that strip away as much needless complexity as possible so you can focus on getting work done quickly without compromising the quality of your work. This can be difficult though because the software development ecosystem is filled with <strong>merchants of complexity</strong> — people who have a vested interest in selling you on solutions that increase complexity, either because they directly profit by it or because they have some ideological attachment to a specific way of doing things that isn't based in good evidence.</p>

      <p>The merchants of complexity are everywhere and it can be difficult to steer clear of them. They will try to convince you that the way you're doing things is unprofessional unless you adopt their preferred, often over-engineered architecture preferences. Don't listen to them. Use the most minimally viable tool at your disposal unless and until you encounter hard evidence that something more is needed. That is the best way to avoid technical debt and get high quality work done quickly.</p>

      <h3 id="humility">The Roosevelt framework team endeavors to not become merchants of complexity ourselves by embracing humility and self-awareness</h3>

      <p>The most insidious thing about the "merchants of complexity" phenomenon is it seems clear the majority of people who are shilling for over-engineered solutions aren't doing it with nefarious intent. They're true believers who really do think the complexity they're selling isn't needless. We recognize that as authors of our own series of libraries and frameworks, we could potentially have our own blind spots in this regard. What if the tools we're promoting are over-engineered too? It wouldn't be the first time an author of a framework promoted it with complexity-reducing branding only to deliver a solution that is also needlessly complicated. It happens all the time.</p>

      <p>We think the best way to avoid falling into that trap is to state our core principles clearly and live by our values. We believe reducing complexity as much as possible empowers people get the best possible work done and we live by our values by remaining constantly vigilant about our own blind spots. We encourage evidence-based discussion and debate about ways to improve our tools either by simplifying them further, or embracing needed complexity that we incorrectly regarded as needless, and we commit to going wherever the evidence leads because <a href="https://en.wikipedia.org/wiki/The_Scout_Mindset">we are scouts, not soldiers</a>.</p>

      <h3 id="modular">Strong opinions, loosely held, expressed as code</h3>

      <p>Because we recognize that aspects of our design philosophy could be wrong, and we respect people's desires to do what they like regardless of what the evidence says is the best approach, our work is designed to be as flexible as possible. We are less interested in selling you on an ideology and more interested in building tools that you find genuinely useful regardless of how much you agree with us about our design philosohpy. Even if you reject a large amount of the recommendations in our design philosophy, much of our work could still be useful to you when assembling your own stack any way you like, if you have that need or desire. Accordingly, below is a list of modules that were built and are maintained by the <a href="/contributors">Roosevelt framework team</a>, but can be used independently of Roosevelt as well.</p>

      <h3 id="modules">Independent projects in the Roosevelt project family</h3>

      <ul>
        <li><a href="/docs/check-if-CSS-is-disabled">check-if-CSS-is-disabled</a>: Frontend JavaScript module that can determine if CSS is disabled or if it failed to load, then take action to stop JS enhancements from applying if the CSS isn't working first.</li>
        <li><a href="/docs/crossplatform-killport">crossplatform-killport</a>: Command line program to kill the process running on a given port in any operating system.</li>
        <li><a href="/docs/express-browser-reload">express-browser-reload</a>: Refresh your browser when your Express server restarts.</li>
        <li><a href="/docs/express-html-validator">express-html-validator</a>: Automatic HTML validation middleware for Express applications.</li>
        <li><a href="/docs/fallback-dependencies">fallback-dependencies</a>: Add git repo dependencies to your Node.js app from a cascading list of fallback locations.</li>
        <li><a href="/docs/minify-html-attributes">minify-html-attributes</a>: Obfuscates your HTML attribute class names, IDs, and <code>data-*</code> attributes in a coordinated fashion across your HTML, CSS, and JS files.</li>
        <li><a href="/docs/multi-db">multi-db</a>: A thin abstraction around selected Node.js database drivers to normalize their APIs to one simplified common API. This makes it possible to write a Node.js app that supports multiple databases by configuration with minimal additional boilerplate needed per additional database.</li>
        <li><a href="/docs/node-php-runner">node-php-runner</a>: Allows you to run PHP code in Node.js in various ways.</li>
        <li><a href="/docs/progressively-enhance-web-components">progressively-enhance-web-components</a>: Template file preprocessor for progressively enhancing web components in Node.js.</li>
        <li><a href="/docs/roosevelt-logger">roosevelt-logger</a>: Intuitive, attractive logger for Node.js applications based on <a href="https://github.com/winstonjs/winston">Winston</a>.</li>
        <li><a href="/docs/semantic-forms">semantic-forms</a>: A pattern library of forms based on semantic HTML enhanced with a modern UX.</li>
        <li><a href="/docs/source-configs">source-configs</a>: Allows you to declaratively define a hierarchy of configuration values for your app from command line arguments, environment variables, or defaults based on a JSON schema you define within your app.</li>
        <li><a href="/docs/single-page-express">single-page-express</a>: A client-side implementation of the Express route API.</li>
        <li><a href="/docs/teddy">teddy</a>: Teddy is the most readable and easy to learn templating language there is!</li>
      </ul>
    </article>
  </arg>
</include>
